# Аудит реализации TG_Parser и план внедрения

Дата: 2026-02-21  
Контекст: [AUDIT-ARCHITECTURE-SCALABILITY-2026-02-21.md](AUDIT-ARCHITECTURE-SCALABILITY-2026-02-21.md)  
Объект: репозиторий TG_Parser (текущее состояние кода)

---

## 1. Цель документа

- Сверить текущую реализацию TG_Parser с целевой архитектурой из стратегического аудита.
- Зафиксировать разрывы: обработка ошибок, коды выхода, логирование, расширяемость, DRY.
- Дать приоритизированные рекомендации и пошаговый план внедрения (без поломки текущего сценария).

---

## 2. Соответствие стратегическому аудиту

Итог стратегического документа:

- **Не дробить** на микросервисы; вести к модульному монолиту с контрактами.
- Ввести единую доменную модель (`ContentItem`), адаптеры источников/назначений, контракты пайплайна (Source → Normalize → Store → Publish).
- Централизовать таксономию ошибок и коды выхода.
- Унифицировать структурированное логирование и summary.

В **текущем репозитории** присутствует только TG_Parser (источник Telegram). VK_Importer и другие получатели в этом репо не рассматриваются; рекомендации сформулированы так, чтобы TG_Parser можно было потом встроить в общий пайплайн (как первый SourceAdapter).

---

## 3. Текущее состояние TG_Parser

### 3.1 Структура и разделение слоёв

| Аспект | Состояние | Оценка |
|--------|-----------|--------|
| CLI vs ядро | `telegram_parser_skill.py` (CLI) отделён от `telegram_parser.py` (ядро) | Хорошо |
| Конфиг/секреты | `.env` + dotenv, секреты не в коде | Хорошо |
| Логирование | Отдельный модуль `logging_setup.py`, JSONL в каталоге экспорта | Хорошо |
| Домен/контракты | Нет абстракций Source/Destination; выход — только JSON-файлы на диск | Требует доработки при добавлении пайплайнов |

**Вывод:** База для одного источника (Telegram) и одного «получателя» (локальный экспорт) достаточная. Для мульти-источников/получателей нужны интерфейсы и единая модель контента.

### 3.2 Обработка ошибок

| Тип | Где | Как обрабатывается |
|-----|-----|--------------------|
| Нет API credentials | CLI | `return 1`, сообщение в stderr и в лог |
| Нет `--channel` для parse/resolve | CLI | `return 1` |
| Режим не safe/normal | parse_channel | `raise ValueError` → ловится в main → `return 1` |
| Первый вход без кода | connect() | `raise RuntimeError` → `return 1` |
| FloodWait | _with_retries | Лог + sleep, повтор без ограничения по числу FloodWait |
| FileReferenceExpiredError | parse_channel | Обновление сообщения, повтор; при повторной ошибке — пропуск файла, сообщение остаётся в export |
| Timeout загрузки медиа | _with_retries | Лог + backoff, до max_retries, затем re-raise |
| Прочие исключения в run() | main() | log.exception + stderr + `return 1` |
| KeyboardInterrupt | main() | `return 130` |

**Проблемы:**

- Нет **единой таксономии** (CONFIG_ERROR, AUTH_ERROR, RATE_LIMIT и т.д.); по логам нельзя однозначно классифицировать сбой для алертов/метрик.
- **Частичный сбой** (часть сообщений/медиа не скачалась) не отличается от полного: всегда `return 1`. Для оркестратора и автоматизации полезен отдельный код (например 2 = partial failure).
- Исключения из ядра (ValueError, RuntimeError) доходят до пользователя как «Error: <текст>» без кода ошибки.

### 3.3 Коды выхода

| Код | Использование сейчас |
|-----|------------------------|
| 0 | Успех (channels, resolve, parse) |
| 1 | Любая ошибка (конфиг, аргументы, API, необработанное исключение) |
| 130 | Ctrl+C |

**Отсутствует:**

- Код **2 (partial failure)** при успешном завершении парсинга с пропущенными медиа/сообщениями.
- Документированная матрица кодов в одном месте (README или docs), чтобы оркестратор/скрипты могли на них опираться.

### 3.4 Логирование

| Место | Формат | Поля |
|-------|--------|------|
| `logs/app.log`, `logs/errors.log` | Текст (asctimeZ level name: message) | Нет run_id, нет единого error_code |
| Экспорт: `.../logs/run.log`, `errors.log` | JSONL | ts, level, event, data |

**Проблемы:**

- Нет **run_id** (correlation id) для связки одного запуска CLI с логами приложения и экспорта.
- Нет единого набора полей (service, step, error_code) для парсинга и алертов.
- Логи приложения не структурированы (не JSONL), сложнее автоматизировать разбор.

### 3.5 Расширяемость и DRY (в рамках TG_Parser)

| Аспект | Состояние |
|--------|------------|
| Парсинг ссылок | Отдельные функции `parse_telegram_link`, `channel_identifier_from_input` — переиспользуемы |
| Режимы (safe/normal) | Пресет в одном месте (MODE_PRESETS) |
| Работа с JSON/диском | _load_json/_save_json, путь к экспорту — только под текущий сценарий «один канал → одна папка» |
| Домен | Сообщения — словари с фиксированными ключами; нет абстракции ContentItem/MessageItem для будущих источников |

**Вывод:** Внутри одного источника (Telegram) дублирования мало. Для добавления других источников (сайты, VK и т.д.) потребуется вынести общий контракт данных и, при необходимости, разнести код по пакетам (например core + sources/telegram).

---

## 4. Рекомендации по изменению системы

Приоритеты согласованы с фазами из стратегического аудита; ниже — что делать именно в репозитории TG_Parser.

### 4.1 Phase 1 (быстро, без ломки текущего поведения)

**1.1 Матрица кодов выхода**

- Ввести константы (например в `telegram_parser_skill.py` или общем модуле `constants.py` / `exit_codes.py`):
  - `EXIT_SUCCESS = 0`
  - `EXIT_FAILURE = 1`
  - `EXIT_PARTIAL = 2`
  - `EXIT_INTERRUPTED = 130`
- Везде использовать константы вместо «магических» чисел.
- Задокументировать матрицу в `docs/cli.md` и в README (кратко).

**1.2 Partial failure (код 2)**

- В `parse_channel` считать «частичный успех»: например, если есть хотя бы одно новое сообщение в export, но при этом были ошибки (retry_exhausted, file_reference_expired, timeout).
- Возвращать из `parse_channel` в результате флаг или счётчик (например `partial_failure: bool` или `errors_count: int`).
- В CLI: при успешном завершении parse и `partial_failure == True` выходить с кодом 2, иначе с 0.

**1.3 Гарантированный non-zero при фатальной ошибке**

- Убедиться, что при любой фатальной ошибке (в т.ч. из ядра) вызывается `sys.exit(1)` или `raise SystemExit(main())` с возвратом 1 из main. Сейчас это уже выполняется через `return 1` и `raise SystemExit(main())` — достаточно проверить все ветки и исключения.

**1.4 Единый summary на команду**

- Для команд `channels` и `resolve` не менять текущий вывод (JSON в stdout).
- Для `parse` уже есть JSON результата с summary — зафиксировать в документации, что этот вывод считается единым summary команды parse (и при необходимости добавить в него поле `exit_code` или `partial_failure` для оркестратора).

### 4.2 Phase 2 (подготовка к контрактам, без смены поведения)

**2.1 run_id (correlation id)**

- В начале `main()` генерировать `run_id` (uuid4 или short id).
- Пробрасывать в `run(args, run_id=...)` и в ядро (например опциональный параметр в `TelegramParser.parse_channel(..., run_id=None)`).
- Добавлять `run_id` во все записи логов (в logging_setup — через Filter или LoggerAdapter; в JsonLogger — в data).

**2.2 Таксономия ошибок (константы)**

- Ввести модуль `errors.py` (или в `constants.py`) с кодами: `CONFIG_ERROR`, `AUTH_ERROR`, `RATE_LIMIT`, `NETWORK_ERROR`, `DATA_FORMAT_ERROR`, `EXTERNAL_API_ERROR`, `PARTIAL_FAILURE`.
- В CLI и ядре при появлении ошибки использовать эти коды и по возможности писать их в лог (поле `error_code`).
- Пока не обязательно маппить все исключения — достаточно начать с CONFIG_ERROR, AUTH_ERROR, EXTERNAL_API_ERROR, PARTIAL_FAILURE.

**2.3 Структурированный лог приложения (опционально)**

- Рассмотреть вывод в `app.log` в формате JSONL (одна строка — один JSON) с полями: ts, level, service, run_id, step, event, error_code?, message, payload.
- Либо оставить текстовый лог, но добавить в него run_id и error_code там, где обрабатываются ошибки.

### 4.3 Phase 3 (контракты и расширяемость)

**3.1 Контракт данных (ContentItem / MessageItem)**

- Ввести в общем модуле (например `core/models.py` или `contracts.py`) dataclass или TypedDict для «нормализованного сообщения»: source_id, external_id, published_at, text, media[], metadata.
- Текущий формат сообщения в export.json оставить как есть; добавить функцию преобразования «текущий словарь сообщения TG → нормализованный контракт». Это позволит в будущем подключать другие источники и один и тот же контракт кормить в разные DestinationAdapter’ы.

**3.2 Интерфейс SourceAdapter (заглушка)**

- Определить абстрактный класс или протокол `SourceAdapter` с методом `fetch(...)` (или `fetch_messages(...)`), возвращающим итератор/список нормализованных элементов.
- Реализацию Telegram оформить как `TelegramSourceAdapter`, оборачивающую текущий `TelegramParser` (или его логику). Не обязательно сразу выносить весь код — достаточно фасада, который вызывает существующий parse и маппит результат в контракт.

**3.3 Skeleton DestinationAdapter**

- Определить протокол `DestinationAdapter` с методом `publish(item)` или `publish_batch(items)`.
- В TG_Parser можно оставить только «локальный экспорт» как реализацию (запись в export.json + медиа на диск). Заглушки для VK/YouTube/Дзен/WP добавлять в том репозитории, где будет общий пайплайн.

### 4.4 Phase 4 (по мере появления потребностей)

- **Не делать** кодовый скелет очереди/сервисов в основном коде до наступления триггеров.
- **Зафиксировать в документации** «контракт будущих изменений»:
  - триггеры старта Phase 4: 2+ источника, 2+ destination, оркестратор, явные SLA;
  - целевые гарантии: idempotency, retry policy, DLQ/failed jobs;
  - минимальные интерфейсы без реализации: `JobStore`, `JobRunner`, `RetryPolicy`;
  - критерии готовности и миграционный план.
- Детали — в [PHASE4-FUTURE-CONTRACT.md](PHASE4-FUTURE-CONTRACT.md) (чек-лист go/no-go).

---

## 5. Пошаговый план внедрения (чек-лист)

Ниже — конкретные шаги для внедрения по фазам. Можно отмечать выполнение прямо в этом документе.

### Phase 1

- [x] **1.1** Добавить модуль/константы кодов выхода (EXIT_SUCCESS, EXIT_FAILURE, EXIT_PARTIAL, EXIT_INTERRUPTED) — `exit_codes.py`.
- [x] **1.2** В `parse_channel` вычислять признак partial_failure (счётчик `media_errors_count` при file_reference_expired) и возвращать в summary и в результате.
- [x] **1.3** В CLI для команды parse: при успешном выполнении и partial_failure выходить с EXIT_PARTIAL (2), иначе EXIT_SUCCESS; при исключении — EXIT_FAILURE; при Ctrl+C — EXIT_INTERRUPTED.
- [x] **1.4** Обновить docs/cli.md и README: таблица кодов выхода, описание кода 2 (partial); в output-formats.md — поля media_errors_count, partial_failure.
- [x] **1.5** Все ветки CLI используют константы и возвращают non-zero при фатальных ошибках (EXIT_FAILURE/EXIT_INTERRUPTED).

### Phase 2

- [ ] **2.1** Генерация run_id в main(), передача в run() и при необходимости в parse_channel.
- [ ] **2.2** Добавление run_id во все записи логов (app + export JSONL).
- [ ] **2.3** Модуль errors.py с кодами ошибок; использование в CLI и ядре при обработке исключений.
- [ ] **2.4** (Опционально) Перевести app.log на JSONL с полями ts, level, service, run_id, step, event, error_code?, message, payload.

### Phase 3

- [ ] **3.1** Ввести контракт нормализованного сообщения (ContentItem/MessageItem) и маппер TG → контракт.
- [ ] **3.2** Ввести протокол SourceAdapter и TelegramSourceAdapter поверх текущего парсера.
- [ ] **3.3** Ввести протокол DestinationAdapter; текущий экспорт в файлы оформить как LocalExportAdapter (или аналог).

### Phase 4

- [ ] Зафиксировать контракт в docs/PHASE4-FUTURE-CONTRACT.md (триггеры, гарантии, интерфейсы JobStore/JobRunner/RetryPolicy, миграционный план, go/no-go).
- [ ] Реализацию очереди/сервисов начинать только после прохождения чек-листа go/no-go.

---

## 6. Ответы на ключевые вопросы

**Оставлять текущий проект или дробить?**  
Оставлять один репозиторий TG_Parser. Дробить на микросервисы не рекомендуется до появления нескольких независимых источников/получателей и отдельной команды/SLA. Внутри репо — двигаться к модульной структуре (core, sources, destinations) и контрактам.

**Насколько удобно расширять сейчас?**  
Добавить ещё один источник (например парсер сайта) или ещё одного получателя (VK/YouTube) без рефакторинга будет неудобно: нет общей модели данных и явных интерфейсов. После Phase 1–3 расширение новыми пайплайнами и получателями станет предсказуемым и DRY.

**Обработка ошибок, коды выхода, логирование.**  
Сейчас: обработка ошибок есть и в целом адекватная; коды выхода — только 0/1/130, без partial; логирование разное (текст vs JSONL), без run_id и единой таксономии. Рекомендации: Phase 1 — коды и partial; Phase 2 — run_id и коды ошибок в логах; при необходимости — единый JSONL для app.log.

---

## 7. Связь с другими документами

- [PHASE4-FUTURE-CONTRACT.md](PHASE4-FUTURE-CONTRACT.md) — контракт будущих изменений Phase 4 (триггеры, интерфейсы, go/no-go).
- [AUDIT-ARCHITECTURE-SCALABILITY-2026-02-21.md](AUDIT-ARCHITECTURE-SCALABILITY-2026-02-21.md) — стратегический аудит и целевой blueprint.
- [docs/cli.md](cli.md) — описание CLI и кодов выхода (после внедрения Phase 1 обновить).
- [docs/logging.md](logging.md) — формат логов (после Phase 2 дополнить run_id и error_code).

После выполнения каждого пункта чек-листа можно обновлять этот документ (отмечать галочки и при необходимости добавлять ссылки на коммиты/файлы).
